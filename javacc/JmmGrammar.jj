PARSER_PACKAGE=pt.up.fe.comp;
PARSER_CLASS=JmmGrammarParser;
SMART_NODE_CREATION=false;

SKIP : " " | "\t" | "\r" | "\n"
        | "/*" : InsideComment
        | < "//" (~["\r", "\n"])* >
;

<InsideComment> SKIP: { "*/ : DEFAULT" }

<InsideComment> MORE : { <~[]> }

TOKEN #NumericalLiteral :
    < INTEGER_LITERAL :
            <BINARY_LITERAL>
        |   <OCTAL_LITERAL>
        |   <HEX_LITERAL>
        |   <DECIMAL_LITERAL>
    > #IntegerLiteral
    |   < #BINARY_LITERAL: "0" ["b", "B"] ["0", "1"] ((["0", "1", "_"])* ["0", "1"])? >
    |   < #OCTAL_LITERAL: "0" ["0"-"7"] ((["0"-"7", "_"])* ["0"-"7"])? >
	|   < #HEX_LITERAL: "0" ["x", "X"] <HEX_DIGITS> >
	|   < #DECIMAL_LITERAL: ["0"-"9"]((["0"-"9","_"])*["0"-"9"])? >
	|   < LONG_LITERAL: <INTEGER_LITERAL> (["l", "L"]) > #LongLiteral
	|   < #HEX_DIGITS: ["0"-"9","a"-"f","A"-"F"]((["0"-"9","a"-"f","A"-"F","_"])*["0"-"9","a"-"f","A"-"F"])? >
;

TOKEN #Operator :
	    < PLUS: "+" >
	|   < MINUS: "-" >
	|   < TIMES: "*" >
	|   < DIVIDE: "/" >
	|   < ASSIGN: "=" >
	|   < AND: "&&" >
	|   < NOT: "!" >
	|   < LT: "<" >
;

TOKEN #Delimiter :
        < LPARENTHESES: "(" >
    |   < RPARENTHESES: ")" >
	|   < LSQUARE_BRACKETS: "[" >
	|   < RSQUARE_BRACKETS: "]" >
    |   < LBRACES: "{" >
    |   < RBRACES: "}" >
	|   < DOT: "." >
	|   < COMMA: "," >
	|   < COLON: ":" >
	|   < SEMICOLON: ";" >
;

TOKEN #KeyWord :
        < IMPORT: "import">
    |   < CLASS: "class">
    |   < PUBLIC: "public">
    |   < STATIC: "static">
    |   < MAIN: "main">
    |   < EXTENDS: "extends" >
    |   < VOID: "void">
    |   < RETURN: "return" >
    |   < LENGTH: "length">
    |   < NEW: "new">
    |   < THIS: "this" >
    |   < IF: "if" >
    |   < ELSE: "else" >
    |   < WHILE: "while" >
    |   < TRUE: "true" > #BooleanLiteral
    |   < FALSE: "false" > #BooleanLiteral
    |   < INT: "int" > #Primitive
    |   < BOOLEAN: "boolean" > #Primitive
;

TOKEN :
	    < IDENTIFIER: ["_","a"-"z","A"-"Z"] (["_","a"-"z","A"-"Z"] | ["0"-"9"])* > #Identifier
;


Start : <AdditiveExpression> <EOF>;


AdditiveExpression :
	MultiplicativeExpression
	(
		(< PLUS > | < MINUS >)
		MultiplicativeExpression
	)?
;

MultiplicativeExpression :
	Factor
	(
		(< TIMES > | < DIVIDE >)
		Factor
	)?
;

Factor :
	< INTEGER_LITERAL > |
	< MINUS> Factor |
	< LPARENTHESES > AdditiveExpression < RPARENTHESES >
;

void ClassDeclaration() : { Token token_name; } {
    <CLASS> token_name = <IDENTIFIER> {jjtThis.name = token_name.image;} (ClassGeneralization)?
    <OPEN_BRACES>
        ClassBody()
    <CLOSE_BRACES>
}

void ClassGeneralization() : { Token token_name; } {
    <EXTENDS> token_name = <IDENTIFIER> {
        jjtThis.name = token_name.image;
    }
}

void ClassBody() #void : { int field_num = 0, method_num = 0; } {

}

