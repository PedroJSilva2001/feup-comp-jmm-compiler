PARSER_PACKAGE=pt.up.fe.comp;
PARSER_CLASS=JmmGrammarParser;
SMART_NODE_CREATION=false;
//BASE_NODE_CLASS="SimpleNode";

SKIP : " " | "\t" | "\r" | "\n"
        | "/*" : InsideComment
        | < "//" (~["\r", "\n"])* >
;

<InsideComment> SKIP: { "*/ : DEFAULT" }

<InsideComment> MORE : { <~[]> }

TOKEN #NumericalLiteral :
    < INTEGER_LITERAL :
            <BINARY_LITERAL>
        |   <OCTAL_LITERAL>
        |   <HEX_LITERAL>
        |   <DECIMAL_LITERAL>
    > #IntegerLiteral
    |   < #BINARY_LITERAL: "0" ["b", "B"] ["0", "1"] ((["0", "1", "_"])* ["0", "1"])? >
    |   < #OCTAL_LITERAL: "0" ["0"-"7"] ((["0"-"7", "_"])* ["0"-"7"])? >
	|   < #HEX_LITERAL: "0" ["x", "X"] <HEX_DIGITS> >
	|   < #DECIMAL_LITERAL: ["0"-"9"]((["0"-"9","_"])*["0"-"9"])? >
	|   < LONG_LITERAL: <INTEGER_LITERAL> (["l", "L"]) > #LongLiteral
	|   < #HEX_DIGITS: ["0"-"9","a"-"f","A"-"F"]((["0"-"9","a"-"f","A"-"F","_"])*["0"-"9","a"-"f","A"-"F"])? >
;

TOKEN #Operator :
	    < PLUS: "+" >
	|   < MINUS: "-" >
	|   < TIMES: "*" >
	|   < DIVIDE: "/" >
	|   < ASSIGN: "=" >
	|   < AND: "&&" >
	|   < NOT: "!" >
	|   < LT: "<" >
;

TOKEN #Delimiter :
        < LPARENTHESES: "(" >
    |   < RPARENTHESES: ")" >
	|   < LSQUARE_BRACKETS: "[" >
	|   < RSQUARE_BRACKETS: "]" >
    |   < LBRACES: "{" >
    |   < RBRACES: "}" >
	|   < DOT: "." >
	|   < COMMA: "," >
	|   < COLON: ":" >
	|   < SEMICOLON: ";" >
;

TOKEN #KeyWord :
        < IMPORT: "import">
    |   < CLASS: "class">
    |   < PUBLIC: "public">
    |   < STATIC: "static">
    |   < MAIN: "main">
    |   < EXTENDS: "extends" >
    |   < VOID: "void">
    |   < RETURN: "return" >
    |   < LENGTH: "length">
    |   < NEW: "new">
    |   < THIS: "this" >
    |   < IF: "if" >
    |   < ELSE: "else" >
    |   < WHILE: "while" >
    |   < TRUE: "true" > #BooleanLiteral
    |   < FALSE: "false" > #BooleanLiteral
    |   < INT: "int" > #Primitive
    |   < BOOLEAN: "boolean" > #Primitive
;

TOKEN :
	    < IDENTIFIER: ["_","a"-"z","A"-"Z"] (["_","a"-"z","A"-"Z"] | ["0"-"9"])* > #Identifier
;


Start : AdditiveExpression <EOF>;


AdditiveExpression :
	MultiplicativeExpression
	(
		(< PLUS > | < MINUS >)
		MultiplicativeExpression
	)?
;

MultiplicativeExpression :
	Factor
	(
		(< TIMES > | < DIVIDE >)
		Factor
	)?
;

Factor :
	< INTEGER_LITERAL > |
	< MINUS> Factor |
	< LPARENTHESES > AdditiveExpression < RPARENTHESES >
;

/*
SimpleNode Program(): {} {
    (ImportDeclaration())*
    ClassDeclaration()
    <EOF>

    { return jjtThis; }
}*/

Start: Program;

Program:
    (ImportDeclaration())*
    ClassDeclaration()
    <EOF>
;

void ImportDeclaration() : { Token token1, token2; } {
    <IMPORT> token1 = <IDENTIFIER> { /* jjtThis.put("name", token1.getImage()); */ }
    (<DOT> token2 = <IDENTIFIER> { /* jjtThis.put("name", token2.getImage()); */ } )* <SEMICOLON>
}

void ClassDeclaration() : { Token token; } {
    <CLASS> token = <IDENTIFIER> {  /*jjtThis.put("name", token1.getImage());*/ } (ClassGeneralization)?
    <LBRACES> ClassBody() <RBRACES>
}

void ClassGeneralization() : { Token token; } {
    <EXTENDS> token = <IDENTIFIER> { /* jjtThis.put("name", token1.getImage()); */ }
}

void ClassBody() #void : {} {
     // TODO: enforce 0 or 1 main (extra)
    (VarDeclaration())* (<PUBLIC> (MainDeclaration() | MethodDeclaration()))*
}

void VarDeclaration() : {} {
    <EOF>
}

void MethodDeclaration() : {} {
    <EOF>
}

void MainDeclaration() : { Token token; } {
    <STATIC> <VOID> <MAIN> <LPARENTHESES> "String" Array() token = <IDENTIFIER> {} <RPARENTHESES>
}

void Array() #void : {} {
    <LSQUARE_BRACKETS> <RSQUARE_BRACKETS>
}